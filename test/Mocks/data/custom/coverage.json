{"repo_token":"XKUga6etuxSWYPXJ0lAiDyHM2jbKPQAKC","source_files":[{"name":"League\/PHPUnitCoverageListener\/Listener.php","source":"<?php namespace League\\PHPUnitCoverageListener;\n\nuse Monad\\Collection;\nuse Symfony\\Component\\Yaml\\Yaml;\nuse \\SimpleXMLElement;\n\n\/**\n * Main PHPUnit listener class\n *\n * @package  League\\PHPUnitCoverageListener\n * @author   Taufan Aditya <toopay@taufanaditya.com>\n *\/\n\nclass Listener implements ListenerInterface\n{\n    \/**\n     * @var string\n     *\/\n    protected $directory;\n\n\t\/**\n\t * @var PrinterInterface\n\t *\/\n\tprotected $printer;\n\n\t\/**\n\t * @var HookInterface\n\t *\/\n\tprotected $hook;\n\n    \/**\n     * Listener constructor\n     *\n     * @param array Argument that sent from phpunit.xml\n     * @param bool Boot flag\n     *\n     * @throws RuntimeException\n     *\/\n    public function __construct($args = array(), $boot = true)\n    {\n        \/\/ Get printer\n        $this->ensurePrinter($args);\n\n    \t$this->printer = $args['printer'];\n\n        \/\/ Get directory\n        $this->directory = (isset($_SERVER['PWD'])) ? realpath($_SERVER['PWD']) : getcwd();\n\n        \/\/ Register the method to collect code-coverage information\n        if ($boot && ($listener = $this)) register_shutdown_function(function() use ($args, $listener) { $listener->handle($args); });\n    }\n\n    \/**\n     * Main handler\n     *\n     * @param array\n     *\n     * @throws RuntimeException\n     *\/\n    public function handle($args)\n    {\n        \/\/ Starting point!\n        $this->printer->out(\"\\n\\n\".'Collecting CodeCoverage information...');\n\n        \/\/ Just collect or also send?\n        if (array_key_exists('send', $args) && $args['send'] == false) {\n            \/\/ In some point we may only want to generate the payload\n            \/\/ so if 'send' parameter exists and set to false we'll only\n            \/\/ collect and write code-coverage payload\n            $this->collectAndWriteCoverage($args);\n        } else {\n            \/\/ Default is to collect and send\n            $this->collectAndSendCoverage($args);\n        }\n\n        \/\/ Done\n        $this->printer->out('Done.');\n    }\n\n    \/**\n     * Printer getter\n     *\n     * @return PrinterInterface\n     *\/\n    public function getPrinter()\n    {\n    \treturn $this->printer;\n    }\n\n    \/**\n     * Directory getter\n     *\n     * @return Path from which the script runs\n     *\/\n    public function getDirectory()\n    {\n        return $this->directory;\n    }\n\n    \/**\n     * Main api for collecting code-coverage information and write it into json\n     * payload\n     *\n     * @param array\n     *\n     * @throws RuntimeException\n     *\/\n    public function collectAndWriteCoverage($args)\n    {\n        if ($this->valid($args)) {\n            extract($args);\n\n            \/\/ Check for exist and valid hook\n            if (isset($hook) && $hook instanceof HookInterface) {\n                $this->hook = $hook;\n                unset($hook);\n            }\n\n            $sep = DIRECTORY_SEPARATOR;\n            \/\/ Get the realpath coverage directory\n            $coverage_dir = realpath($coverage_dir);\n            $coverage_file = \"{$coverage_dir}{$sep}\" . (isset($coverage_file)? $coverage_file : self::COVERAGE_FILE);\n            $coverage_output = \"{$coverage_dir}{$sep}\" . (isset($coverage_output) ? $coverage_output :self::COVERAGE_OUTPUT);\n\n            \/\/ Get the coverage information\n            if (is_dir($coverage_dir) && is_file($coverage_file)) {\n                \/\/ Build the coverage xml object\n                $xml = file_get_contents($coverage_file);\n                $coverage = new SimpleXMLElement($xml);\n\n                \/\/ Prepare the coveralls payload\n                $data = $this->unserialize($this->collect($coverage, $args)->toArray());\n\n                \/\/ Write the coverage output\n                $this->printer->out('Writing coverage output to ' . $coverage_output);\n                file_put_contents($coverage_output, json_encode($data, JSON_NUMERIC_CHECK));\n                return;\n            }\n\n            $this->printer->out(\"Cannot locate coverage file at {$coverage_file}\");\n        }\n    }\n\n    \/**\n     * Main api for collecting code-coverage information\n     *\n     * @param array Contains repo secret hash, target url, coverage directory and\n     *                       optional Namespace\n     *\n     * @throws RuntimeException\n     *\/\n    public function collectAndSendCoverage($args)\n    {\n        \/\/ Collect and write out the data\n        $this->collectAndWriteCoverage($args);\n\n        if ($this->valid($args)) {\n            extract($args);\n\n            $sep = DIRECTORY_SEPARATOR;\n            \/\/ Get the realpath coverage directory\n            $coverage_dir = realpath($coverage_dir);\n            $coverage_output = \"{$coverage_dir}{$sep}\" . (isset($coverage_output) ? $coverage_output :self::COVERAGE_OUTPUT);\n\n\n            \/\/ Send it!\n            $this->printer->out('Sending coverage output...');\n\n\n            \/\/ Workaround for cURL create file\n            if (function_exists('curl_file_create')) {\n                $payload = curl_file_create('json_file', 'application\/json', $coverage_output);\n            } else {\n                $payload = array('json_file'=>'@'.$coverage_output);\n            }\n\n            $ch = curl_init(); \n            curl_setopt($ch, CURLOPT_URL, $target_url); \n            curl_setopt($ch, CURLOPT_POST,1); \n            curl_setopt($ch, CURLOPT_POSTFIELDS, $payload);\n\n            \/\/ Save output into output buffer\n            ob_start();\n            $result = curl_exec ($ch); \n            $curlOutput = ob_get_contents();\n            ob_end_clean();\n\n            curl_close ($ch); \n            $this->printer->printOut('cURL Output:'.$curlOutput); \n            $this->printer->printOut('cURL Result:'.$result);\n        }\n    }\n\n    \/**\n     * Argument validator\n     *\n     * @param array\n     * @return bool\n     *\/\n    protected function valid($args = array())\n    {\n         return array_key_exists('repo_token', $args) \n            && array_key_exists('target_url', $args)\n            && array_key_exists('coverage_dir', $args)\n            && array_key_exists('namespace', $args);\n    }\n\n    \/**\n     * Printer validator\n     *\n     * @param array\n     *\n     * @throws RuntimeException\n     *\/\n    protected function ensurePrinter($args)\n    {\n        if ( ! isset($args['printer'])) {\n            throw new \\RuntimeException('Printer class not found');\n        }\n\n\n        if ( ! $args['printer'] instanceof PrinterInterface) {\n            throw new \\RuntimeException('Invalid printer class');\n        }\n    }\n\n    \/**\n     * Main collector method\n     *\n     * @param SimpleXMLElement Coverage report from PHPUnit\n     * @param array\n     *\n     * @return Collection\n     *\n     * @throws RuntimeException\n     *\/\n    protected function collect(SimpleXMLElement $coverage, $args = array())\n    {\n    \textract($args);\n\n    \t$data = new Collection(array(\n            'repo_token' => $repo_token,\n            'source_files' => serialize([]),\n            'run_at' => gmdate('Y-m-d H:i:s -0000'),\n            'git' => serialize($this->collectFromGit()->toArray()),\n        ));\n\n \t\t\/\/ Before collect hook\n     \tif ( ! empty($this->hook)) {\n     \t\t$data = $this->hook->beforeCollect($data);\n     \t}\n\n        \/\/ Prepare temporary source_files holder\n        $sourceArray = new Collection([], 'string');\n\n        if (count($coverage->project->package) > 0) {\n            \/\/ Iterate over the package\n            foreach ($coverage->project->package as $package) {\n                \/\/ Then itterate on each package file\n                foreach ($package->file as $packageFile) {\n                    $this->printer->printOut('Checking:'.$packageFile['name']);\n\n                    $sourceArray = $sourceArray->append(\n                        [\n                            md5($packageFile['name']) => $this->collectFromFile($packageFile, $namespace)\n                        ]\n                    );\n                }\n            }\n        }\n\n        \/\/ In case the files are not using any namespace at all...\n        \/\/ @codeCoverageIgnoreStart\n        if (count($coverage->project->file) > 0) {\n            \/\/ itterate over the files\n            foreach ($coverage->project->file as $file) {\n                $this->printer->printOut('Checking:'.$file['name']);\n\n                $sourceArray->add(array(\n                    md5($file['name']) => $this->collectFromFile($file, $namespace)\n                ));\n            }\n        }\n        \/\/ @codeCoverageIgnoreEnd\n\n        \/\/ Last, pass the source information it it contains any information\n        if ($sourceArray->count() > 0) {\n            $data = $data->append(['source_files' => serialize(array_values($sourceArray->toArray()))]);\n        }\n\n \t\t\/\/ After collect hook\n        if ( ! empty($this->hook)) {\n     \t\t$data = $this->hook->afterCollect($data);\n     \t}\n\n     \treturn $data;\n    }\n\n    \/**\n     * Collect code-coverage information from a file\n     *\n     * @param SimpleXMLElement contains coverage information\n     * @param string Optional file namespace identifier\n     *\n     * @return array contains code-coverage data with keys as follow : name, source, coverage\n     *\n     * @throws RuntimeException\n     *\/\n    protected function collectFromFile(SimpleXMLElement $file, $namespace = '')\n    {\n        \/\/ Validate\n        if ( ! is_file($file['name'])) throw new \\RuntimeException('Invalid '.self::COVERAGE_FILE.' file');\n\n        \/\/ Get current dir\n        $currentDir = $this->getDirectory();\n\n        \/\/ Initial return values\n        $name = '';\n        $source = '';\n        $coverage = array();\n\n        \/\/ #1 Get the relative file name\n        $pathComponents = explode($currentDir, $file['name']);\n        $relativeName = count($pathComponents) == 2 ? $pathComponents[1] : current($pathComponents);\n        $name = trim($relativeName, DIRECTORY_SEPARATOR);\n\n        if ( ! empty($namespace)) {\n            \/\/ Replace backslash with directory separator\n            $ns = str_replace('\\\\', DIRECTORY_SEPARATOR, $namespace);\n            $nsComponents = explode($ns, $relativeName);\n            $namespacedName = count($nsComponents) == 2 ? $nsComponents[1] : current($nsComponents);\n\n            $name = count($nsComponents) == 2 ? $ns.DIRECTORY_SEPARATOR.trim($namespacedName, DIRECTORY_SEPARATOR) : $namespacedName;\n        }\n\n        \/\/ Then, we will overwrite any coverage block into it!\n        if (count($file->line) > 1) {\n            \/\/ #2 Build coverage data and the source code\n            $count = 0;\n            $handle = fopen($file['name'], \"r\");\n            while(!feof($handle)){\n                $source .= fgets($handle);\n                $count++;\n            }\n\n            fclose($handle);\n\n            \/\/ Here we build the default coverage values\n            $coverage = array_fill(0, $count, null);\n\n            foreach ($file->line as $line) {\n                $attributes = current($line->attributes());\n\n                \/\/ Only stmt would be count\n                if (isset($attributes['type']) \n                    && isset($attributes['count']) \n                    && $attributes['type'] === 'stmt') {\n\n                    \/\/ Decrease the line number by one\n                    \/\/ since key 0 (within coverage array) is actually line number 1\n                    $num = (int) $attributes['num'] - 1;\n\n                    \/\/ Ensure it match count boundaries\n                    if ($num > 0 && $num <= $count) {\n                        $coverage[$num] = (int) $attributes['count'];\n                    }\n                }\n            }\n        }\n\n        return serialize(compact('name', 'source', 'coverage'));\n    }\n\n    \/**\n     * Collect git information\n     *\n     * @return Collection\n     *\/\n    public function collectFromGit()\n    {\n        \/\/ Initial git data\n        $git = new Collection([], 'string');\n\n        $gitDirectory = $this->getDirectory().DIRECTORY_SEPARATOR.self::GIT_DIRECTORY;\n\n        if (is_dir($gitDirectory)) {\n            \/\/ Get refs info from HEAD\n            $branch = '';\n            $head = Yaml::parse($gitDirectory.DIRECTORY_SEPARATOR.self::GIT_HEAD);\n\n            \/\/ @codeCoverageIgnoreStart\n            if (is_array($head) && array_key_exists('ref', $head)) {\n                $ref = $head['ref'];\n                $r = explode('\/', $ref);\n                $branch = array_pop($r);\n            } \n            \/\/ @codeCoverageIgnoreEnd\n\n            \/\/ Assign branch information\n            $git = $git->append(['branch' => $branch]);\n\n            \/\/ Get log information\n            $logRaw = self::execute('cd '.$this->getDirectory().';git log -1');\n            $idRaw = $logRaw[0];\n            $authorRaw = $logRaw[1];\n\n            \/\/ Build head information\n            if (strpos($authorRaw, '<') !== false) {\n                 list($author, $email) = explode('<', str_replace('Author:', '', $authorRaw));\n\n                $id = trim(str_replace('commit', '', $idRaw));\n                $author_name = $committer_name = trim($author);\n                $author_email = $committer_email = trim($email, '>');\n                $message = $logRaw[4].(isset($logRaw[5]) ? '...' : '');\n            }\n           \n\n            \/\/ Assign Head information\n            $git = $git->append(['head' => serialize(compact('id', 'author_name', 'author_email',\n                            'committer_name', 'committer_email', 'message'))]);\n\n            \/\/ Get remotes information\n            $remotes = array();\n            $configRaw = self::execute('cd '.$this->getDirectory().';git config --local -l');\n            array_walk($configRaw,function($v) use(&$remotes)\n            {\n                if (0 === strpos($v, 'remote')) {\n                    list($key, $prop) = explode('=', $v);\n                    $k = explode('.', $key);\n                    $attribute = array_pop($k);\n                    $name = array_pop($k);\n                    $remotes[$name]['name'] = $name;\n                    $remotes[$name][$attribute] = $prop;\n                }\n            });\n\n            \/\/ Assign Remotes information\n            $git = $git->append(['remotes' => serialize(array_values($remotes))]);\n        }\n\n        return $git;\n    }\n\n    \/**\n     * Unserialize the data Collection\n     *\n     * @param array $data\n     *\n     * @return array\n     *\/\n    protected function unserialize(array $data)\n    {\n        $unserialized = [];\n        foreach ($data as $key => $value) {\n            $v = @\\unserialize($value);\n            $unserialized[$key] = ($v === false ? $value : (is_array($v) ? $this->unserialize($v) : $v));\n        }\n\n        return $unserialized;\n    }\n\n    \/**\n     * Execute a command and parse the output as array\n     *\n     * @param string \n     * @return array \n     *\/\n    protected static function execute($command)\n    {\n        $res = array();\n\n        ob_start();\n        passthru($command, $success);\n        $output = ob_get_clean();\n\n        foreach ((explode(\"\\n\", $output)) as $line) $res[] = trim($line);\n\n        return array_filter($res);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,1,null,null,2,1,null,null,1,null,null,1,0,null,null,null,0,0,0,null,1,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,0,null,0,0,0,0,0,null,null,0,0,0,0,null,null,0,0,0,null,null,0,null,0,0,null,null,0,null,null,0,0,null,null,0,0,0,0,0,0,null,null,0,0,0,0,null,0,0,0,0,0,null,0,0,null,null,null,null,null,null,null,null,null,null,0,null,0,0,0,0,null,null,0,0,0,null,null,0,null,0,null,0,null,0,0,null,0,0,0,0,0,0,null,0,null,0,0,null,0,0,0,0,0,null,null,0,0,0,null,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,0,0,null,null,0,null,0,0,0,null,0,0,null,0,null,null,null,0,0,0,0,0,0,null,0,null,null,0,null,null,0,0,0,null,null,0,0,0,null,null,null,0,null,null,0,0,0,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"League\/PHPUnitCoverageListener\/Hook\/Travis.php","source":"<?php namespace League\\PHPUnitCoverageListener\\Hook;\n\nuse League\\PHPUnitCoverageListener\\HookInterface;\nuse Monad\\Collection;\n\n\/**\n * Travis Hook\n *\n * @package  League\\PHPUnitCoverageListener\n * @author   Taufan Aditya <toopay@taufanaditya.com>\n *\/\n\nclass Travis implements HookInterface\n{\n    \/**\n     *{@inheritdoc}\n     *\/\n    public function beforeCollect(Collection $data)\n    {\n        \/\/ Check for Travis-CI environment\n        \/\/ if it appears, then assign it respectively\n        if (getenv('TRAVIS_JOB_ID') || isset($_ENV['TRAVIS_JOB_ID'])) {\n            \/\/ Remove repo token\n            $data = $data->kDiff(new Collection(['repo_token' => '']));\n\n            \/\/ And use travis config\n            $travis_job_id = isset($_ENV['TRAVIS_JOB_ID']) ? $_ENV['TRAVIS_JOB_ID'] : getenv('TRAVIS_JOB_ID');\n            $data = $data ->append(['service_name' => 'travis-ci'])\n                ->append(['service_job_id' => $travis_job_id]);\n        }\n\n        return $data;\n    }\n\n    \/**\n     *{@inheritdoc}\n     *\/\n    public function afterCollect(Collection $data)\n    {\n        return $data;\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,0,0,null,0,null,null,null,null,null,null,null,0,null,null,null]},{"name":"League\/PHPUnitCoverageListener\/Printer\/ArrayOut.php","source":"<?php namespace League\\PHPUnitCoverageListener\\Printer;\n\nuse League\\PHPUnitCoverageListener\\PrinterInterface;\n\n\/**\n * Array printer\n *\n * @package  League\\PHPUnitCoverageListener\n * @author   Taufan Aditya <toopay@taufanaditya.com>\n *\/\n\nclass ArrayOut implements PrinterInterface\n{\n    \/**\n     * @var array Output array\n     *\/\n    public $output = array();\n\n    \/**\n     *{@inheritdoc}\n     *\/\n    public function out($output = '')\n    {\n        $this->output[] = $output.\"\\n\";\n    }\n\n    \/**\n     *{@inheritdoc}\n     *\/\n    public function printOut($output = '')\n    {\n        $this->output[] = str_pad(' ', 2, '*').' '.$output;\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,0,0,null]}],"run_at":"2018-02-17 09:50:43 -0000","git":{"branch":"","head":{"id":"63cbac6b125cc42efbf986827548bd60fe7e2c1a","author_name":"Ashley Kitson","author_email":"ashley.kitson@freetimers.com","committer_name":"Ashley Kitson","committer_email":"ashley.kitson@freetimers.com","message":"move tests to their own directory.  set minimum php to 5.6"},"remotes":[{"name":"origin","url":"git@github.com:chippyash\/phpunit-coverage-listener.git","fetch":"+refs\/heads\/*:refs\/remotes\/origin\/*"}]}}